# 1. JVM이란 무엇인가?

자바 언어는 **Write once, run anywhere** 이라는 특징을 갖고 있고, 이것을 실현가능하게 해주는 것이 바로 이 JVM 입니다. JVM은 크게 4가지의 구성요소로 구성되어있습니다.

### 1. Excecution Engine - Load 된 바이트코드를 실행하는 Runtime Module.

JVM은 OS와 Application 단 사이에서 자바코드가 컴파일된 .class 바이트 코드를 해석하여 이를 실행하는 역할을 하고있고, 이를 통해 어떤 실행환경에서 실행시키든 JVM이 해석한 결과는 항상 같은 실행 결과라는것을 기대할 수 있습니다. 즉, JVM은 자바코드의 실행환경을 제공합니다.

### 2. Runtime Data Area - 자바 어플리케이션을 수행할때 필요한 데이터의 Area.

JVM은 런타임 환경이고, 이 환경안에는 개발자가 작성한 자바 어플리케이션을 실행할 데이터들의 관리가 필요합니다. JVM은 이 DATA를 5개의 영역에 걸쳐 구분해서 관리하고 있으며 구성요소는 다음과 같습니다.

**1. Method Area (모든 쓰레드 공유)**

- 클래스 type

  - interface, abstract 등등

- 클래스 필드

  - 멤버 변수의 이름,데이터타입,접근제어자 등

- 클래스 메서드

  - 메소드의 리턴타입,파라미터,접근제어자 등

- Runtime Constant Pool
  - 클래스가 가진 메소드,필드,문자열 상수등의 실제 물리적 메모리 위치를 참조할수있는 레퍼런스들을 갖고있습니다. 필요할때만 참조할 수 있으므로 모든 바이트코드를 해석하지 않고 실행해야하는 바이트코드만을 찾아 메모리에 적재할 수 있습니다.

**2. Heap Area (모든 쓰레드 공유)**  
 인스턴스화 된 객체들이 저장되는 공간입니다. 즉 new 를 통해서 실제로 인스턴스화된 객체들이 힙에 올라가게 됩니다.

**3. JVM Stack (쓰레드 별 할당)**  
 JVM Stack에는 각 메소드를 위한 Stack Frame이 있으며 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되어 있습니다. 만약 메소드가 호출되면 JVM Stack은 해당 메소드의 Stack Frame을 push 하고, 수행되면 Stack Frame을 Stack에서 pop하게 됩니다.

**4. PC Register (쓰레드 별 할당)**  
 PC Registers는 각 JVM 스레드에 존재하는데, JVM 스레드가 시작할 때 생성되고, 쓰레드가 수행중인 바이트 코드 명령어의 주소를 나타내고 있다. JVM 당 하나의 PC Registers가 존재한다. (수행상태를 저장하고 있기 때문에 멀티쓰레딩을 가능하게 한다.)

**5. Native Method Stack (쓰레드 별 할당)**  
 스레드에서 네이티브 메소드가 실행되는 경우 Native Method Stack에 쌓입니다. Java 메소드를 실행하는 경우 JVM 스택에 메소드가 적재되지만, 해당 메소드 내부에 네이티브 방식을 사용하는 메소드(일반적으로 C,C++로 작성됨) 가 있다면 해당 메소드는 네이티브 스택에 적재되어 수행되고, Native Method Stack에서 자바 메소드가 수행되려한다면 다시 JVM Stack으로 돌아가 메소드가 적재되어 수행됩니다.

### 3. GarbageColltion - 시스템 리소스 공간 할당, 반환을 개발자 대신 수행하는 똑똑한 친구.

C 언어에서는 개발자가 시스템콜을 통해 시스템에게 직접 메모리 공간을 할당받고(Memory allocation) 사용한다음 메모리를 반환합니다(Memory free). 반면에, Java에서는 이런 allocation-free의 과정을 Garbage Collection 이라는 프로세스를 통해서 메모리를 할당하고, 해제하는 작업을 JVM이 모두 수행해주고 있습니다. 개인적인 의견으로 Java 진영에서는 오히려 개발자가 메모리에 직접 관여하는것을 지양하는것 같고, GC에 대한 Custom을 통해 성능을 올리는것을 권장하는것 같아 보입니다.

### 4. ClassLoader - 자바 바이트코드를 해석하고 class 객체를 생성하는 번역가.

클래스 로더는 한번에 모든 클래스가 메모리에 올라가지 않습니다. 각 클래스들은 필요할때만 메모리에 올라가서 어플리케이션에서 사용되게 되며, 이것을 동적로딩이라고 합니다. 그리고 이것은 클래스로더가 있기때문에 가능합니다. 클래스로더는 아래 3가지 책임을 가지고있습니다.

- Loading : 클래스 파일에서 클래스 이름, 상속관계, 클래스의 타입(class, interface, enum) 정보, 메소드 & 생성자 & 멤버변수 정보, 상수 등에 대한 정보를 로딩해서 Binary 데이터로 변경합니다.

- Linking : Verification 과 Preparation, Resolution 단계를 거치면서 바이트코드를 검증하고 필요한 만큼의 메모리를 할당한다. Resolution 과정에서는 Symbolic Reference 를 Direct Reference 등으로 바꿔줍니다.

- Initialization : static block 의 초기화 및 static 데이터들을 할당합니다. Top->Bottom 방식으로 클래스들을 해석합니다.

# 2.컴파일 하는 방법

자바 코드가 작성된 .java 파일을 자바 컴파일러를 통해(javac 명령) 바이트코드(.class) 로 컴파일합니다. 이 바이트코드는 이후 JVM에 의해 해석되어 실행되게 됩니다.

# 3.실행하는 방법

컴파일된 바이트코드가 JVM의 클래스로더(Class Loader)에게 전달되어 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area)에 적재합니다. 이후 Excecution Engine이 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다.

# 4.바이트코드란 무엇인가

바이트 코드란 개발자가 작성한 자바 코드가 자바 컴파일러(javac)를 통해 자바 가상 머신이 이해할 수 있게 변환된 형태의 코드를 뜻합니다. 자바 바이트코드는 .class 확장자를 가지고 있으며, 자바 코드와는 다소 다르게 생겼습니다.

# 5.JIT 컴파일러란 무엇이며 어떻게 동작하는지

자바 바이트코드를 실행하는 실행엔진 방식은 Interpreter와 JIT(Just-In-Time) Compiler가 있습니다.
초기에는 Interpreter 방식으로 바이트코드가 수행되었습니다. 하지만 Interpreter는 바이트 코드를 한줄씩 읽기 때문에 실행이 느린 단점이 있었습니다. 이러한 단점을 보완하기 위해 나온 것이 JIT Compiler 입니다.

JIT Compiler는 자주 사용되는 메소드는 실행시 미리 기계어로 컴파일하고 메소드 영억에 있는 코드캐시 공간에 컴파일된 기계어 코드를 캐시합니다.반면에 자주 사용되지 않는 메소드는 미리 컴파일 하지 않았다가, 호출되었을때만 클래스 로더를 통해 바이트코드를 로드하여 컴파일하게 됩니다. JIT 컴파일러에서는 이 과정을 최적화라고 부르며, JIT 컴파일러의 최적화 레벨이 높을수록 미리 컴파일되어 캐싱될 바이트코드의 양이 작아지게 됩니다. 하지만 동적으로 바이트코드를 다시 로드할 양이 많이질 수 있기 때문에 메모리 측면에서는 비용이 더 높아질 수 도 있습니다.

# 6.JVM 구성 요소

1번에 적어버렸네요ㅜ.ㅜ

# 7.JDK와 JRE의 차이

JDK는 컴파일된 자바 Application을 실행할 수 있는 환경을 뜻합니다, 즉 JVM과 Java API만이 포함되어있습니다.

JDK는 JRE보다 더 큰 개념으로, 자바 개발 환경을 말합니다. JVM과 Java API 뿐만아니라 자바 컴파일러,디버거 등 자바 개발환경에 필요한 도구 또한 포함합니다.
