 # Algorithm 



### 1. 재귀함수(exclusive function)을 구현할때에는 다소 Flat하게 바라보아야 한다. 일정 부분에서 생각하고 파라미터에 의해 따라가기 보다는 현재 상황에서 처리를 할 수있게끔 생각하면 오히려 더 쉽게 다가 올 수 있음.

### 2. O(NlogN) 정도만 만들어도 꽤 괜찮은 알고리즘이라고 생각 해도 된다.

### 3. 재귀함수를 짤때는 중복호출을 유의해야 한다. 중복호출이 너무 많이 발생한다면 메모이제이션을 활용해보자 

메모이제이션- 이미 한 연산의 결과는 저장해두고 다음에 같은값이 필요할때 연산은 하지않고 값을 그대로 가져오는것. 연산 오버헤드를 줄일 수 있다.

```
fibo(n)
    if n<1 then
        return n;
    else return fibo(n-1) + fibo(n-2)
```
위 코드에서는 연산 중복이 많이 발생한다. 

메모이제이션을 통해 해결해보자.

n+1 만큼의 메모이제이션 배열을 할당하고, 여기 값을 저장하여 사용한다면? fibo(n)까지의 값을 저장할 수 있다. 

```
fibo(n)
    if n >= 2 and memo[n] is zero then
        memo[n] = fibo(n-1) + fibo(n-2);
    return memo[n];
end fibo()
```

작은 메모리공간을 사용해서 엄청난 효과를 누릴 수 있다.


### 4. 순열

##### 순열 예시| N개의 서로 다른 색깔의 공 중에 r개를 뽑아서 나열하는 경우의 수 

입력의 크기가 고정되어있는 순열일때 여러번의 작업이 필요하다면, 여러개의 순열을 사용하기보다는 인덱스를 통해 순열 테이블을 생성하면 단 1회만 순열연산을 해도 좋을 수 있다.

> 순열은 어떻게 만들어 내면 좋을까? 

```
#pseudocode
for i1 from 1 to 3
    for i2 from 1 to 3
        if i2 != i1 then
            for i3 from 1 to 3
                if i3!=i1 and i3!=i2 then
                    print i1,i2,i3
```

재귀 호출을 통한 순열 생성
```
pseudocode
numbers [] :순열 저장 배열
isSelected[] : 인덱스에 해당하는 숫자가 사용중인 지 아닌지 빠르게 판단하기위해.(중복체크)

```

numbers[] 가 필요한 이유 : 재귀 호출을 사용하기 때문에 이전에 뽑힌 수를 알 수 있도록 해야한다.

isSelected[] : 메모리 공간을 약간 더 쓰고 비교횟수를 줄인다는 마인드


재귀의 파라미터는 결정요인이 되는것이 일반적임.
